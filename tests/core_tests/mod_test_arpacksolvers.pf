module mod_test_arpacksolvers
  use mod_suite_utils
  use funit
  use mod_solvers, only: solve_evp
  use mod_arpack_type, only: arpack_type
  use mod_global_variables, only: ir, ic, number_of_eigenvalues, arpack_mode, &
    which_eigenvalues
  implicit none

  type(arpack_type)         :: arpackparams
  complex(dp), allocatable  :: amat(:, :)
  real(dp), allocatable     :: bmat(:, :)
  complex(dp), allocatable  :: vl(:, :), vr(:, :)
  complex(dp), allocatable  :: eigenvals(:)
  complex(dp), allocatable  :: expected(:, :)

  character(2)  :: which_to_test(6) = ["LM", "SM", "LR", "SR", "LI", "SI"]

contains


  subroutine reset_arrays(ndim)
    integer, intent(in) :: ndim

    if (allocated(amat)) then
      deallocate(amat)
    end if
    allocate(amat(ndim, ndim))
    if (allocated(bmat)) then
      deallocate(bmat)
    end if
    allocate(bmat(ndim, ndim))
    if (allocated(vl)) then
      deallocate(vl)
    end if
    allocate(vl(ndim, ndim))
    if (allocated(vr)) then
      deallocate(vr)
    end if
    allocate(vr(ndim, ndim))
    if (allocated(eigenvals)) then
      deallocate(eigenvals)
    end if
    allocate(eigenvals(number_of_eigenvalues))
    if (allocated(expected)) then
      deallocate(expected)
    end if
    allocate(expected(size(which_to_test), number_of_eigenvalues))
    expected = (0.0d0, 0.0d0)
  end subroutine reset_arrays


  @before
  subroutine init_test()
    use mod_global_variables, only: solver, maxiter

    call reset_globals()
    call reset_fields(init_fields=.true.)
    call reset_eigenfunctions(init_efs=.false.)
    solver = "arnoldi"
    ! default maxiter=10*N is too low in some cases
    maxiter = 2000
    number_of_eigenvalues = 4
    call reset_arrays(ndim=10)
  end subroutine init_test


  @after
  subroutine teardown_test()
    call clean_up()
    call arpackparams % tear_down()
  end subroutine teardown_test


  @test
  subroutine test_arpack_bad_nev()
    write(*, *) "Testing ARPACK: invalid number_of_eigenvalues"
    number_of_eigenvalues = -1
    call arpackparams % initialise(evpdim=10)
    @assertExceptionRaised("number_of_eigenvalues must be >= 0, but is equal to -1")
    call arpackparams % tear_down()

    number_of_eigenvalues = 12
    call arpackparams % initialise(evpdim=10)
    @assertExceptionRaised("number_of_eigenvalues larger than matrix size! (12 > 10)")
  end subroutine test_arpack_bad_nev


  @test
  subroutine test_arpack_bad_maxiter()
    use mod_global_variables, only: maxiter

    write(*, *) "Testing ARPACK: invalid maxiter"
    maxiter = -1
    call arpackparams % initialise(evpdim=10)
    @assertExceptionRaised("maxiter has to be positive, but is equal to -1")
  end subroutine test_arpack_bad_maxiter


  @test
  subroutine test_arpack_bad_which()
    write(*, *) "Testing ARPACK: invalid which_eigenvalues"
    which_eigenvalues = "LL"
    call arpackparams % initialise(evpdim=10)
    @assertExceptionRaised("which_eigenvalues = LL is invalid")
  end subroutine test_arpack_bad_which


  @test
  subroutine test_arpack_bad_arpackmode()
    write(*, *) "Testing ARPACK: invalid arpack_mode"
    arpack_mode = "test_fail"
    call solve_evp(amat, bmat, eigenvals, vl, vr)
    @assertExceptionRaised("unknown mode for ARPACK: test_fail")
  end subroutine test_arpack_bad_arpackmode


  @test
  subroutine test_arpack_bad_mode_nb()
    write(*, *) "Testing ARPACK: invalid mode number"
    call arpackparams % set_mode(0)
    @assertExceptionRaised("mode must be 1, 2 or 3 but mode = 0 was given")
    call arpackparams % set_mode(4)
    @assertExceptionRaised("mode must be 1, 2 or 3 but mode = 4 was given")
  end subroutine test_arpack_bad_mode_nb


  @test
  subroutine test_arpack_bad_sigma()
    write(*, *) "Testing ARPACK: invalid sigma"
    call arpackparams % set_sigma((0.0d0, 0.0d0))
    @assertExceptionRaised("ARPACK shift-invert: sigma can not be equal to zero")
  end subroutine test_arpack_bad_sigma


  @test
  subroutine test_arpack_edge_sigma()
    write(*, *) "Testing ARPACK: Re/Im sigma = 0"
    ! should raise no errors
    call arpackparams % set_sigma((1.0d0, 0.0d0))
    call arpackparams % set_sigma((0.0d0, 1.0d0))
  end subroutine test_arpack_edge_sigma


  @test
  subroutine test_arpack_standard()
    use mod_solvers, only: solvers_clean

    real(dp)  :: custom_tol
    integer   :: i

    write(*, *) "Testing ARPACK: Ax = wx"
    arpack_mode = "standard"
    amat = reshape( &
      (/ &
         1*ir, 2*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir, &
         2*ic, 1*ic, -1*ir,  0*ir,  0*ir,  0*ir,  0*ir,  2*ic,  0*ir,  0*ir, &
        -3*ir, 3*ir, -2*ic, -1*ic,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir, &
         0*ir, 5*ic,  4*ir, -3*ic, -1*ic,  2*ic,  0*ir,  0*ir,  0*ir,  0*ir, &
         1*ir, 0*ir,  2*ir,  2*ic,  3*ic, -7*ir,  1*ic, -3*ir,  0*ir,  0*ir, &
         0*ir, 0*ir,  3*ic,  4*ir,  5*ic, -3*ir, -1*ir, -5*ic,  2*ic,  0*ir, &
         0*ir, 0*ir,  0*ir,  3*ir, -5*ir, -1*ic,  4*ic,  7*ic,  2*ir,  1*ic, &
         0*ir, 0*ir,  0*ir,  0*ir,  6*ic,  0*ir, -7*ir, -3*ir,  1*ic, -2*ir, &
        -1*ir, 0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  1*ir, -3*ir,  5*ic, &
         0*ir, 0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  2*ic,  5*ir &
      /), &
      shape(amat) &
    )
    call create_identity_matrix(ndim=10, mat=bmat)
    ! fill expected values, all solutions are obtained through scipy.sparse.linalg.eigs
    ! mode = "LM"
    expected(1, :) = (/ &
      (-7.88387658940d0, 4.1991444332407d0), &
      (-5.138261241954d0, 7.5009013739202d0), &
      (0.31046578943724d0, -4.047463930579d0), &
      (5.2400515042190d0, -6.595821187876d0) &
    /)
    ! mode = "SM"
    expected(2, :) = (/ &
      (-1.8535519260158162d0, -2.3664867110999914d0), &
      (-1.1552554495101768d0, -0.035423895485982966d0), &
      (0.24267531391652103d0, 0.03073408215019738d0), &
      (2.990390817288886d0, 0.9764506866571272d0) &
    /)
    ! mode = "LR"
    expected(3, :) = (/ &
      (0.7986174799734262d0, 3.1698016541082943d0), &
      (2.990390817288887d0, 0.9764506866571241d0), &
      (3.4487443020471886d0, 0.16816349496512467d0), &
      (5.24005150421897d0, -6.595821187876013d0) &
    /)
    ! mode = "SR"
    expected(4, :) = (/ &
      (-7.883876589401881d0, 4.199144433240658d0), &
      (-5.13826124195435d0, 7.5009013739201595d0), &
      (-1.8535519260158175d0, -2.366486711099991d0), &
      (-1.155255449510177d0, -0.035423895485983105) &
    /)
    ! mode = "LI"
    expected(5, :) = (/ &
      (-7.883876589401901d0, 4.199144433240657d0), &
      (-5.138261241954358d0, 7.500901373920169d0), &
      (0.7986174799734265d0, 3.169801654108291d0), &
      (2.9903908172888825d0, 0.9764506866571268d0) &
    /)
    ! mode = "SI"
    expected(6, :) = (/ &
      (-1.8535519260158189d0, -2.3664867110999865d0), &
      (-1.155255449510176d0, -0.03542389548598286d0), &
      (0.31046578943724584d0, -4.047463930579591d0), &
      (5.2400515042189735d0, -6.595821187875999d0) &
    /)

    do i = 1, size(which_to_test)
      which_eigenvalues = which_to_test(i)
      write(*, *) " - Testing '" // adjustl(trim(which_eigenvalues)) // "' eigenvalues"
      call solve_evp(amat, bmat, eigenvals, vl, vr)
      call sort_complex_array(eigenvals)
      ! specify custom tolerance for comparison Python-Fortran (1e-12 is a bit strict)
      custom_tol = 1.0d-10
      if (i == 4) then
        ! slight deviation for mode="SR" but imaginary part still within 1e-8
        custom_tol = 1.0d-8
      end if
      @assertEqual(expected(i, :), eigenvals, tolerance=custom_tol)
      ! manual deallocation of residual_norm since we're still in the same test
      call solvers_clean()
    end do
  end subroutine test_arpack_standard


  @test
  subroutine test_arpack_general
    use mod_solvers, only: solvers_clean

    real(dp)  :: custom_tol
    integer   :: i

    write(*, *) "Testing ARPACK: Ax = wBx"
    arpack_mode = "general"
    amat = reshape( &
      (/ &
         1*ir, 2*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir, &
         2*ic, 1*ic, -1*ir,  0*ir,  0*ir,  0*ir,  0*ir,  2*ic,  0*ir,  0*ir, &
        -3*ir, 3*ir, -2*ic, -1*ic,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir, &
         0*ir, 5*ic,  4*ir, -3*ic, -1*ic,  2*ic,  0*ir,  0*ir,  0*ir,  0*ir, &
         1*ir, 0*ir,  2*ir,  2*ic,  3*ic, -7*ir,  1*ic, -3*ir,  0*ir,  0*ir, &
         0*ir, 0*ir,  3*ic,  4*ir,  5*ic, -3*ir, -1*ir, -5*ic,  2*ic,  0*ir, &
         0*ir, 0*ir,  0*ir,  3*ir, -5*ir, -1*ic,  4*ic,  7*ic,  2*ir,  1*ic, &
         0*ir, 0*ir,  0*ir,  0*ir,  6*ic,  0*ir, -7*ir, -3*ir,  1*ic, -2*ir, &
        -1*ir, 0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  1*ir, -3*ir,  5*ic, &
         0*ir, 0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  0*ir,  2*ic,  5*ir  &
      /), &
      shape(amat) &
    )
    ! this matrix is symmetric and positive definite, as it should be
    bmat = reshape( &
      (/ &
        9.0d0,  2.0d0,  8.0d0,  1.0d0,  2.0d0,  0.0d0,  0.0d0,  0.0d0, 0.0d0, 0.0d0, &
        2.0d0, 23.0d0, -4.0d0, -5.5d0,-10.0d0,  0.0d0,  0.0d0,  0.0d0, 0.0d0, 0.0d0, &
        8.0d0, -4.0d0, 15.0d0, -9.5d0, -3.0d0,  0.0d0,  0.0d0,  0.0d0, 0.0d0, 0.0d0, &
        1.0d0, -5.5d0, -9.5d0,60.25d0, -9.5d0,  0.0d0,  0.0d0,  0.0d0, 0.0d0, 0.0d0, &
        2.0d0,-10.0d0, -3.0d0, -9.5d0, 51.0d0,  0.0d0,  0.0d0,  0.0d0, 0.0d0, 0.0d0, &
        0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, 18.0d0, 11.0d0, 27.0d0, 4.0d0, 0.0d0, &
        0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, 11.0d0, 14.0d0, 13.0d0, 3.0d0, 0.0d0, &
        0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, 27.0d0, 13.0d0, 51.0d0, 5.5d0, 1.0d0, &
        0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  4.0d0,  3.0d0,  5.5d0,2.25d0, 3.5d0, &
        0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0, 3.5d0, 10.0d0 &
      /), &
      shape(bmat) &
    )
    ! fill expected values, all solutions are obtained through scipy.sparse.linalg.eigs
    ! mode = "LM"
    expected(1, :) = (/ &
      (-47.2665629010241d0, -53.44467400017329d0), &
      (-2.189909116110393d0, 2.5207526151739104d0), &
      (0.27674478315351964d0, -0.05805107198127579d0), &
      (3.255610316647699d0, -1.7224326867994835d0) &
    /)
    ! mode = "SM"
    expected(2, :) = (/ &
      (-0.1090874990971426d0, 0.07259700665954608d0), &
      (-0.09731865560338829d0, -0.07865430786985059d0), &
      (0.005806290449585147d0, -0.00571678567700864d0), &
      (0.09148540813167974d0, -0.09425266599250161d0) &
    /)
    ! mode = "LR"
    expected(3, :) = (/ &
      (0.09148540813169981d0, -0.09425266599249923d0), &
      (0.18564017432800176d0, -0.018108179117325113d0), &
      (0.2767447831535259d0, -0.05805107198128537d0), &
      (3.2556103166476946d0, -1.7224326867994848d0) &
    /)
    ! mode = "SR"
    expected(4, :) = (/ &
      (-47.26656290102423d0, -53.44467400017332d0), &
      (-2.1899091161103916d0, 2.5207526151739206d0), &
      (-0.10908749909714037d0, 0.07259700665954676d0), &
      (-0.09731865560338862d0, -0.07865430786985349d0) &
    /)
    ! mode = "LI"
    expected(5, :) = (/ &
      (-2.18990911611039d0, 2.5207526151739192d0),&
      (-0.10908749909713217d0, 0.07259700665954318d0), &
      (0.005806290449592661d0, -0.0057167856770139625d0), &
      (0.07082410204964182d0, 0.17332751670248298d0) &
    /)
    ! mode = "SI"
    expected(6, :) = (/ &
      (-47.26656290102416d0, -53.44467400017327d0), &
      (-0.09731865560338793d0, -0.07865430786985747d0), &
      (0.0914854081317005d0, -0.09425266599247786d0), &
      (3.255610316647708d0, -1.7224326867994837d0) &
    /)

    do i = 1, size(which_to_test)
      which_eigenvalues = which_to_test(i)
      write(*, *) " - Testing '" // adjustl(trim(which_eigenvalues)) // "' eigenvalues"
      call solve_evp(amat, bmat, eigenvals, vl, vr)
      call sort_complex_array(eigenvals)
      custom_tol = 1.0d-10
      @assertEqual(expected(i, :), eigenvals, tolerance=custom_tol)
      call solvers_clean()
    end do
  end subroutine test_arpack_general

end module mod_test_arpacksolvers
