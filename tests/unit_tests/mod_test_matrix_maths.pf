module mod_test_matrix_maths
  use mod_suite_utils
  use funit
  use mod_matrix_structure, only: matrix_t, new_matrix
  use mod_transform_matrix, only: array_to_matrix, matrix_to_array

  real(dp) :: rmat1(4, 4) = reshape( &
    [ &
      3.0d0, 0.0d0, -1.0d0, 0.0d0, &
      0.0d0, 1.0d0, 0.0d0, 0.0d0, &
      7.0d0, 0.0d0, 2.0d0, -1.0d0, &
      -1.0d0, 5.0d0, 8.0d0, 4.0d0 &
    ], &
    shape=[4, 4] &
  )
  real(dp) :: rmat2(4, 4) = reshape( &
    [ &
      4.0d0, -1.0d0, 0.0d0, 3.0d0, &
      -2.0d0, 0.0d0, 1.0d0, 2.0d0, &
      7.0d0, -3.0d0, 0.0d0, -1.0d0, &
      -1.0d0, 0.0d0, -3.0d0, 3.0d0 &
    ], &
    shape=[4, 4] &
  )
  complex(dp) :: cmat1(4, 4) = reshape( &
    [ &
      (2.0d0, 1.0d0), (-3.0d0, 1.0d0), (0.0d0, 0.0d0), (0.0d0, 0.0d0), &
      (-3.5d0, -2.0d0), (1.4d0, 1.2d0), (-1.9d0, -2.4d0), (0.0d0, 0.0d0), &
      (0.0d0, 0.0d0), (0.0d0, 0.0d0), (3.0d0, 2.1d0), (2.9d0, 7.4d0), &
      (-5.0d1, 8.3d0), (4.5d0, -9.5d0), (0.0d0, 7.5d0), (2.9d0, 3.5d0) &
    ], &
    shape=[4, 4] &
  )
  complex(dp) :: cmat2(4, 4) = reshape( &
    [ &
      (7.0d0, 1.0d0), (-3.0d0, -5.0d0), (0.0d0, 0.0d0), (0.0d0, 2.3d0), &
      (-3.5d0, -2.0d0), (1.4d0, 5.2d0), (-1.9d0, -2.4d0), (1.0d0, 0.0d0), &
      (0.0d0, 5.0d0), (3.0d0, 0.1d0), (3.0d2, 2.1d0), (-2.9d0, 7.4d0), &
      (4.0d1, 2.3d0), (4.5d0, -9.5d0), (0.8d0, -1.0d0), (2.9d0, 3.5d0) &
    ], &
    shape=[4, 4] &
  )

  type(matrix_t) :: matrix, matrix1, matrix2

contains


  @before
  subroutine init_test()
    call reset_globals()
  end subroutine init_test


  @after
  subroutine tear_down()
    call matrix1%delete_matrix()
    call matrix2%delete_matrix()
    call matrix%delete_matrix()
  end subroutine tear_down


  @test
  subroutine test_real_matrix_addition()
    complex(dp) :: actual(4, 4), expected(4, 4)

    call set_name("matrix maths: real matrix addition")
    matrix1 = array_to_matrix(array=rmat1)
    matrix2 = array_to_matrix(array=rmat2)
    matrix = matrix1 + matrix2
    call matrix_to_array(matrix, actual)

    expected = cmplx(rmat1 + rmat2, kind=dp)
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_real_matrix_addition


  @test
  subroutine test_complex_matrix_addition()
    complex(dp) :: actual(4, 4), expected(4, 4)

    call set_name("matrix maths: complex matrix addition")
    matrix1 = array_to_matrix(array=cmat1)
    matrix2 = array_to_matrix(array=cmat2)
    matrix = matrix1 + matrix2
    call matrix_to_array(matrix, actual)

    expected = cmat1 + cmat2
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_complex_matrix_addition


  @test
  subroutine test_matrix_real_vector_multiplication()
    real(dp) :: vector(4)
    complex(dp) :: expected(4), actual(4)

    call set_name("matrix maths: matrix and real vector multiplication")
    vector = [-1.0d0, 2.5d0, -1.2d0, 4.5d0]
    matrix = array_to_matrix(array=rmat1)
    actual = matrix * vector

    expected = cmplx(matmul(rmat1, vector), kind=dp)
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_matrix_real_vector_multiplication


  @test
  subroutine test_matrix_complex_vector_multiplication()
    complex(dp) :: vector(4), expected(4), actual(4)

    call set_name("matrix maths: matrix and complex vector multiplication")
    vector = [(1.2d0, -3.9d0), (-2.6d0, 1.0d0), (0.0d0, 0.0d0), (-3.4d0, 7.5d0)]
    matrix = array_to_matrix(array=cmat1)
    actual = matrix * vector

    expected = matmul(cmat1, vector)
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_matrix_complex_vector_multiplication


  @test
  subroutine test_matrix_addition_submatrix()
    complex(dp) :: actual(4, 4), expected(4, 4)

    call set_name("matrix maths: matrix and submatrix addition")
    matrix1 = array_to_matrix(array=rmat1)
    matrix2 = array_to_matrix(array=rmat2(1:3, 1:2))
    matrix = matrix1 + matrix2
    call matrix_to_array(matrix, actual)

    expected = cmplx( &
      reshape( &
        [ &
          7.0d0, -1.0d0, -1.0d0, 0.0d0, &
          -2.0d0, 1.0d0, 1.0d0, 0.0d0, &
          7.0d0, 0.0d0, 2.0d0, -1.0d0, &
          -1.0d0, 5.0d0, 8.0d0, 4.0d0 &
        ], &
        shape=[4, 4] &
      ), &
      kind=dp &
    )
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_matrix_addition_submatrix


  @test
  subroutine test_matrix_addition_unequal()
    complex(dp) :: actual(5, 5), expected(5, 5)
    real(dp) :: rmat(5, 5)

    call set_name("matrix maths: unequal matrix addition")
    matrix1 = array_to_matrix(array=rmat1(1:3, 1:3))
    rmat = reshape( &
      [ &
        4.0d0, -1.0d0, 0.0d0, 3.0d0, 1.0d0, &
        -2.0d0, 0.0d0, 1.0d0, 2.0d0, 2.0d0, &
        7.0d0, -3.0d0, 0.0d0, -1.0d0, 3.0d0, &
        -1.0d0, 0.0d0, -3.0d0, 3.0d0, -1.5d0, &
        -3.0d0, 2.5d0, 1.0d0, -1.0d0, 2.0d0 &
      ], &
      shape=[5, 5] &
    )
    matrix2 = array_to_matrix(array=rmat)
    matrix = matrix1 + matrix2
    @assertEqual(5, matrix%matrix_dim)
    call matrix_to_array(matrix, actual)

    expected = cmplx( &
      reshape( &
        [ &
          7.0d0, -1.0d0, -1.0d0, 3.0d0, 1.0d0, &
          -2.0d0, 1.0d0, 1.0d0, 2.0d0, 2.0d0, &
          14.0d0, -3.0d0, 2.0d0, -1.0d0, 3.0d0, &
          -1.0d0, 0.0d0, -3.0d0, 3.0d0, -1.5d0, &
          -3.0d0, 2.5d0, 1.0d0, -1.0d0, 2.0d0 &
        ], &
        shape=[5, 5] &
      ), &
      kind=dp &
    )
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_matrix_addition_unequal


  @test
  subroutine test_multiply_real_matrix_real_number()
    complex(dp) :: expected(4, 4), actual(4, 4)
    real(dp), parameter :: number = 1.5d0

    call set_name("matrix maths: multiply real matrix with real number")
    matrix = array_to_matrix(array=rmat1) * number
    call matrix_to_array(matrix, actual)

    expected = cmplx(rmat1 * number, kind=dp)
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_multiply_real_matrix_real_number


  @test
  subroutine test_multiply_real_matrix_complex_number()
    complex(dp) :: expected(4, 4), actual(4, 4)
    complex(dp), parameter :: number = (0.75d0, -2.3d0)

    call set_name("matrix maths: multiply real matrix with complex number")
    matrix = array_to_matrix(array=rmat2) * number
    call matrix_to_array(matrix, actual)

    expected = rmat2 * number
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_multiply_real_matrix_complex_number


  @test
  subroutine test_multiply_complex_matrix_real_number()
    complex(dp) :: expected(4, 4), actual(4, 4)
    real(dp), parameter :: number = 1.5d0

    call set_name("matrix maths: multiply complex matrix with real number")
    matrix = array_to_matrix(array=cmat1) * number
    call matrix_to_array(matrix, actual)

    expected = cmat1 * number
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_multiply_complex_matrix_real_number


  @test
  subroutine test_multiply_complex_matrix_complex_number()
    complex(dp) :: expected(4, 4), actual(4, 4)
    complex(dp), parameter :: number = (7.2d0, -3.8d0)

    call set_name("matrix maths: multiply complex matrix with complex number")
    matrix = array_to_matrix(array=cmat2) * number
    call matrix_to_array(matrix, actual)

    expected = cmat2 * number
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_multiply_complex_matrix_complex_number


  @test
  subroutine test_combined_real_plus_real()
    complex(dp) :: expected(4, 4), actual(4, 4)
    real(dp), parameter :: number = 2.3d0

    call set_name("matrix maths: combined operation A + rB (all real)")
    matrix1 = array_to_matrix(array=rmat1)
    matrix2 = array_to_matrix(array=rmat2)
    matrix = matrix1 + matrix2 * number
    call matrix_to_array(matrix, actual)

    expected = cmplx(rmat1 + number * rmat2, kind=dp)
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_combined_real_plus_real


  @test
  subroutine test_combined_real_plus_complex()
    complex(dp) :: expected(4, 4), actual(4, 4)
    complex(dp), parameter :: number = (2.3d0, -1.4d0)

    call set_name("matrix maths: combined operation A + rB (r complex)")

    matrix1 = array_to_matrix(array=rmat1)
    matrix2 = array_to_matrix(array=rmat2)
    matrix = matrix1 + matrix2 * number
    call matrix_to_array(matrix, actual)

    expected = rmat1 + number * rmat2
    @assertEqual(expected, actual, tolerance=TOL)
  end subroutine test_combined_real_plus_complex

end module mod_test_matrix_maths
